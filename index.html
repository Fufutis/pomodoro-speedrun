<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>Sequential Speedrunning Pomodoro (Session + Task-Specific Finish Info, MM:SS)</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 20px;
            background: #fafafa;
        }

        h1 {
            text-align: center;
        }

        .timers {
            text-align: center;
            margin: 30px 0;
        }

        /* The current task timer: big, bold */
        #currentTaskTimer {
            font-size: 4rem;
            font-weight: bold;
            margin: 10px 0;
        }

        /* The total timer: smaller */
        #totalTimer {
            font-size: 1.5rem;
            margin: 5px 0;
        }

        .negative {
            color: red !important;
        }

        #controls {
            text-align: center;
            margin: 10px 0;
        }

        #addTaskBtn,
        #startAllBtn,
        #finishCurrentBtn {
            padding: 10px 20px;
            font-size: 1rem;
            cursor: pointer;
            margin: 5px;
        }

        .task-list {
            margin: 0 auto;
            max-width: 600px;
        }

        .task-row {
            display: flex;
            align-items: flex-start;
            /* so we can stack finish info if needed */
            gap: 10px;
            background: #fff;
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #ccc;
        }

        .task-info {
            display: flex;
            flex-direction: column;
            flex: 1;
        }

        .task-name-label {
            font-weight: bold;
        }

        .task-row input[type="text"],
        .task-row input[type="number"] {
            width: 140px;
            padding: 5px;
            font-size: 1rem;
        }

        /* This is where we display the finish info for each task */
        .task-finish-info {
            font-size: 0.9rem;
            margin-top: 8px;
            min-height: 1.2em;
            /* to keep space even if blank */
        }

        .task-finish-info.early {
            color: green;
        }

        .task-finish-info.late {
            color: red;
        }
    </style>
</head>

<body>

    <h1>Sequential Speedrunning Pomodoro (Session-Based, MM:SS)</h1>

    <div class="timers">
        <!-- Big "current" timer -->
        <div id="currentTaskTimer">00:00</div>
        <!-- Smaller "total" timer -->
        <div id="totalTimer">Total: 00:00</div>
    </div>

    <div id="controls">
        <button id="addTaskBtn">Add Task</button>
        <button id="startAllBtn">Start All</button>
        <button id="finishCurrentBtn" disabled>Finish Current Task</button>
    </div>

    <div class="task-list" id="taskContainer"></div>

    <script>
        /************************************************************************
         * SESSION DATA STRUCTURE
         *
         * We'll store and restore the following in sessionStorage:
         * {
         *   tasks: [
         *     { name: string, minutes: number, finishInfo: string|null }
         *   ],
         *   currentTaskIndex: number,
         *   currentTaskEndTime: number|null,  // ms timestamp
         *   totalEndTime: number|null,        // ms timestamp
         *   isSequenceRunning: boolean,       // did we press StartAll?
         * }
         ************************************************************************/

        let currentTaskInterval = null;
        let totalTimerInterval = null;

        /** In-memory data we sync with sessionStorage. **/
        let sessionData = {
            tasks: [],
            currentTaskIndex: -1,
            currentTaskEndTime: null,
            totalEndTime: null,
            isSequenceRunning: false
        };

        /** We'll keep an array of DOM references. 
         *  Each entry matches sessionData.tasks[index].
         *  We add a "finishInfoElem" to display the finish text in that row.
         */
        const taskDOMs = []; // { row, nameInput, minInput, finishInfoElem }

        /************************************************************************
         * ON PAGE LOAD
         ************************************************************************/
        window.addEventListener('DOMContentLoaded', () => {
            loadSessionData();
            initUIFromSession();
            setupEventHandlers();
        });

        /************************************************************************
         * SETUP EVENT HANDLERS
         ************************************************************************/
        function setupEventHandlers() {
            document.getElementById('addTaskBtn').addEventListener('click', addTask);
            document.getElementById('startAllBtn').addEventListener('click', startAll);
            document.getElementById('finishCurrentBtn').addEventListener('click', finishCurrentTask);
        }

        /************************************************************************
         * LOAD SESSION DATA
         ************************************************************************/
        function loadSessionData() {
            const saved = sessionStorage.getItem('seqPomodoroData');
            if (!saved) {
                return; // no saved data
            }
            const parsed = JSON.parse(saved);

            sessionData.tasks = parsed.tasks || [];
            sessionData.currentTaskIndex = parsed.currentTaskIndex ?? -1;
            sessionData.currentTaskEndTime = parsed.currentTaskEndTime ?? null;
            sessionData.totalEndTime = parsed.totalEndTime ?? null;
            sessionData.isSequenceRunning = parsed.isSequenceRunning ?? false;
        }

        /************************************************************************
         * SAVE SESSION DATA
         ************************************************************************/
        function saveSessionData() {
            sessionStorage.setItem('seqPomodoroData', JSON.stringify(sessionData));
        }

        /************************************************************************
         * INIT UI FROM SESSION
         * 1) Rebuild the task rows from sessionData.tasks
         * 2) If isSequenceRunning, re-init intervals for current & total timers
         ************************************************************************/
        function initUIFromSession() {
            // Rebuild tasks
            for (let i = 0; i < sessionData.tasks.length; i++) {
                const t = sessionData.tasks[i];
                createTaskRow(t.name, t.minutes, t.finishInfo);
            }

            // If we have tasks, possibly update the "Finish Current" button
            if (
                sessionData.currentTaskIndex >= 0 &&
                sessionData.currentTaskIndex < sessionData.tasks.length
            ) {
                document.getElementById('finishCurrentBtn').disabled = false;
            }

            // If the sequence was running, re-init intervals
            if (sessionData.isSequenceRunning) {
                // Start total timer if needed
                if (sessionData.totalEndTime) {
                    startTotalTimerInterval();
                }
                // Start current task timer if needed
                if (
                    sessionData.currentTaskIndex >= 0 &&
                    sessionData.currentTaskIndex < sessionData.tasks.length
                ) {
                    startCurrentTaskInterval();
                } else if (sessionData.currentTaskIndex >= sessionData.tasks.length) {
                    // Means "All done"
                    document.getElementById('currentTaskTimer').textContent = 'ALL DONE';
                    document.getElementById('finishCurrentBtn').disabled = true;
                }
            }

            // Immediately update timer displays
            updateCurrentTaskTimerDisplay();
            updateTotalTimerDisplay();
        }

        /************************************************************************
         * CREATE TASK ROW (DOM)
         * If name/minutes/finishInfo are given, we populate them, otherwise empty
         ************************************************************************/
        function createTaskRow(nameVal = '', minsVal = '', finishText = null) {
            const row = document.createElement('div');
            row.classList.add('task-row');

            const taskInfo = document.createElement('div');
            taskInfo.classList.add('task-info');

            // Task Name
            const nameLabel = document.createElement('label');
            nameLabel.classList.add('task-name-label');
            nameLabel.textContent = 'Task Name: ';
            const nameInput = document.createElement('input');
            nameInput.type = 'text';
            nameInput.value = nameVal;
            nameInput.placeholder = 'My Task';

            // Task Minutes
            const minLabel = document.createElement('label');
            minLabel.textContent = 'Minutes: ';
            const minInput = document.createElement('input');
            minInput.type = 'number';
            minInput.min = '1';
            minInput.value = minsVal;
            minInput.placeholder = '5';

            taskInfo.appendChild(nameLabel);
            taskInfo.appendChild(nameInput);
            taskInfo.appendChild(minLabel);
            taskInfo.appendChild(minInput);

            // This is where we display finish info (early/late + total at that moment)
            const finishInfoElem = document.createElement('div');
            finishInfoElem.classList.add('task-finish-info');
            if (finishText) {
                finishInfoElem.innerHTML = finishText;
                if (finishText.includes('early')) {
                    finishInfoElem.classList.add('early');
                } else if (finishText.includes('late')) {
                    finishInfoElem.classList.add('late');
                }
            }

            // Put them together
            taskInfo.appendChild(finishInfoElem);
            row.appendChild(taskInfo);
            document.getElementById('taskContainer').appendChild(row);

            // Keep references
            taskDOMs.push({
                row,
                nameInput,
                minInput,
                finishInfoElem
            });
        }

        /************************************************************************
         * ADD TASK BUTTON HANDLER
         ************************************************************************/
        function addTask() {
            createTaskRow();
            // Also push to sessionData
            sessionData.tasks.push({ name: '', minutes: 5, finishInfo: null });
            saveSessionData();
        }

        /************************************************************************
         * START ALL (SEQUENCE)
         ************************************************************************/
        function startAll() {
            if (sessionData.tasks.length === 0) {
                alert('Please add at least one task first.');
                return;
            }

            // Validate
            let totalMins = 0;
            for (let i = 0; i < taskDOMs.length; i++) {
                const name = taskDOMs[i].nameInput.value.trim();
                const mins = parseInt(taskDOMs[i].minInput.value, 10);

                if (!name || isNaN(mins) || mins <= 0) {
                    alert('All tasks must have a valid name and positive minutes.');
                    return;
                }
            }

            // Update sessionData from DOM
            totalMins = 0;
            for (let i = 0; i < sessionData.tasks.length; i++) {
                sessionData.tasks[i].name = taskDOMs[i].nameInput.value.trim();
                sessionData.tasks[i].minutes = parseInt(taskDOMs[i].minInput.value, 10);
                // Clear old finish info
                sessionData.tasks[i].finishInfo = null;

                totalMins += sessionData.tasks[i].minutes;
            }

            const now = Date.now();
            // totalEndTime
            sessionData.totalEndTime = now + totalMins * 60 * 1000;
            // currentTaskIndex => 0
            sessionData.currentTaskIndex = 0;
            // currentTaskEndTime => now + (minutes of first task)
            if (sessionData.tasks.length > 0) {
                const firstTaskMins = sessionData.tasks[0].minutes;
                sessionData.currentTaskEndTime = now + firstTaskMins * 60 * 1000;
            }
            sessionData.isSequenceRunning = true;

            // Clear old intervals if any
            if (totalTimerInterval) clearInterval(totalTimerInterval);
            if (currentTaskInterval) clearInterval(currentTaskInterval);

            // Start intervals
            startTotalTimerInterval();
            startCurrentTaskInterval();

            // Enable "Finish Current Task"
            document.getElementById('finishCurrentBtn').disabled = false;

            // Save
            saveSessionData();
        }

        /************************************************************************
         * FINISH CURRENT TASK BUTTON
         ************************************************************************/
        function finishCurrentTask() {
            // Stop current task interval
            if (currentTaskInterval) {
                clearInterval(currentTaskInterval);
                currentTaskInterval = null;
            }

            // figure out the CURRENT index & times
            const idx = sessionData.currentTaskIndex;
            if (idx < 0 || idx >= sessionData.tasks.length) {
                // nothing to do
                return;
            }

            const now = Date.now();
            const diffSec = Math.floor((sessionData.currentTaskEndTime - now) / 1000);

            // Also figure out how much total time was left
            let totalDiffSec = null;
            if (sessionData.totalEndTime) {
                totalDiffSec = Math.floor((sessionData.totalEndTime - now) / 1000);
            }

            // Convert these to MM:SS
            const absTask = Math.abs(diffSec);      // absolute seconds for current task
            const absTotal = totalDiffSec !== null ? Math.abs(totalDiffSec) : null;

            // Build a message
            let message = '';
            let cssClass = ''; // 'early' or 'late'

            if (diffSec > 0) {
                // Early
                message = `Finished ${formatMinSec(absTask)} early`;
                cssClass = 'early';
            } else {
                // Late
                message = `Finished ${formatMinSec(absTask)} late`;
                cssClass = 'late';
            }

            // Also mention total time at that moment in MM:SS
            if (totalDiffSec !== null) {
                if (totalDiffSec > 0) {
                    message += `, with ${formatMinSec(absTotal)} left in total`;
                } else {
                    message += `, and you're ${formatMinSec(absTotal)} over total`;
                }
            }

            // Save that message to sessionData for this task
            sessionData.tasks[idx].finishInfo = message;
            // Update the DOM for that row
            const finishElem = taskDOMs[idx].finishInfoElem;
            finishElem.textContent = message;
            finishElem.classList.remove('early', 'late');
            finishElem.classList.add(cssClass);

            // Move to next
            sessionData.currentTaskIndex++;
            if (sessionData.currentTaskIndex >= sessionData.tasks.length) {
                // ALL DONE
                document.getElementById('finishCurrentBtn').disabled = true;
                document.getElementById('currentTaskTimer').textContent = 'ALL DONE';
                sessionData.currentTaskEndTime = null;
            } else {
                // Start the next task
                const nextTaskMins = sessionData.tasks[sessionData.currentTaskIndex].minutes;
                sessionData.currentTaskEndTime = now + nextTaskMins * 60 * 1000;
                startCurrentTaskInterval();
            }

            // Save
            saveSessionData();
        }

        /************************************************************************
         * START CURRENT TASK INTERVAL
         ************************************************************************/
        function startCurrentTaskInterval() {
            if (currentTaskInterval) clearInterval(currentTaskInterval);
            currentTaskInterval = setInterval(() => {
                updateCurrentTaskTimerDisplay();
            }, 1000);

            // Update immediately
            updateCurrentTaskTimerDisplay();
        }

        /************************************************************************
         * START TOTAL TIMER INTERVAL
         ************************************************************************/
        function startTotalTimerInterval() {
            if (totalTimerInterval) clearInterval(totalTimerInterval);
            totalTimerInterval = setInterval(() => {
                updateTotalTimerDisplay();
            }, 1000);

            // Update once right away
            updateTotalTimerDisplay();
        }

        /************************************************************************
         * UPDATE CURRENT TASK TIMER DISPLAY (MM:SS)
         ************************************************************************/
        function updateCurrentTaskTimerDisplay() {
            const timerElem = document.getElementById('currentTaskTimer');

            // If no current task or all done
            if (
                sessionData.currentTaskIndex < 0 ||
                sessionData.currentTaskIndex >= sessionData.tasks.length ||
                !sessionData.currentTaskEndTime
            ) {
                return;
            }

            const now = Date.now();
            let diffSec = Math.floor((sessionData.currentTaskEndTime - now) / 1000);

            if (diffSec <= 0) {
                // Negative
                const late = Math.abs(diffSec);
                const mins = Math.floor(late / 60);
                const secs = late % 60;
                timerElem.classList.add('negative');
                timerElem.textContent = `-${padZero(mins)}:${padZero(secs)}`;
            } else {
                // Positive
                const mins = Math.floor(diffSec / 60);
                const secs = diffSec % 60;
                timerElem.classList.remove('negative');
                timerElem.textContent = `${padZero(mins)}:${padZero(secs)}`;
            }
        }

        /************************************************************************
         * UPDATE TOTAL TIMER DISPLAY (MM:SS)
         ************************************************************************/
        function updateTotalTimerDisplay() {
            const totalElem = document.getElementById('totalTimer');
            if (!sessionData.totalEndTime) {
                totalElem.textContent = 'Total: 00:00';
                return;
            }

            const now = Date.now();
            let diffSec = Math.floor((sessionData.totalEndTime - now) / 1000);

            if (diffSec <= 0) {
                // Negative
                const late = Math.abs(diffSec);
                const mins = Math.floor(late / 60);
                const secs = late % 60;
                totalElem.classList.add('negative');
                totalElem.textContent = `Total: -${padZero(mins)}:${padZero(secs)}`;
            } else {
                // Positive
                const mins = Math.floor(diffSec / 60);
                const secs = diffSec % 60;
                totalElem.classList.remove('negative');
                totalElem.textContent = `Total: ${padZero(mins)}:${padZero(secs)}`;
            }
        }

        /************************************************************************
         * HELPER: formatMinSec (returns MM:SS for a number of seconds)
         ************************************************************************/
        function formatMinSec(sec) {
            const mins = Math.floor(sec / 60);
            const remainder = sec % 60;
            return `${padZero(mins)}:${padZero(remainder)}`;
        }

        /************************************************************************
         * HELPER: padZero
         ************************************************************************/
        function padZero(num) {
            return num < 10 ? '0' + num : num;
        }
    </script>
</body>

</html>