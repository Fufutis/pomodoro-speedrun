<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>Speedrunning Pomodoro (Cumulative + SessionStorage)</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 20px;
            background: #fafafa;
        }

        h1 {
            text-align: center;
        }

        #controls {
            text-align: center;
            margin-bottom: 20px;
        }

        #addTaskBtn,
        #startAllBtn {
            padding: 10px 20px;
            font-size: 1rem;
            cursor: pointer;
            margin: 10px;
        }

        .big-timer-container {
            text-align: center;
            margin-bottom: 20px;
        }

        .big-timer {
            font-size: 3rem;
            font-weight: bold;
            margin-top: 10px;
        }

        .negative {
            color: red !important;
        }

        .task-row {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 10px;
            background: #fff;
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #ccc;
        }

        .task-row input[type="text"],
        .task-row input[type="number"] {
            width: 120px;
            padding: 5px;
            font-size: 1rem;
        }

        .task-row button {
            padding: 8px 12px;
            font-size: 0.9rem;
            cursor: pointer;
        }

        .timer-display {
            font-size: 1.2rem;
            width: 80px;
            text-align: center;
        }

        .result {
            margin-left: 20px;
            font-style: italic;
            color: #333;
            width: 250px;
        }
    </style>
</head>

<body>

    <h1>Speedrunning Pomodoro (Cumulative + Session-Based)</h1>

    <!-- Big Timer Display -->
    <div class="big-timer-container">
        <div>Total Time (Cumulative):</div>
        <div id="bigTimer" class="big-timer">00:00</div>
    </div>

    <div id="controls">
        <button id="addTaskBtn">Add Task</button>
        <button id="startAllBtn">Start All</button>
    </div>

    <div id="taskContainer"></div>

    <script>
        /****************************************************
         * GLOBAL DATA
         ****************************************************/
        let totalIntervalId = null;   // interval for the big timer
        const tasks = [];             // will hold { domRefs..., data... }

        // We'll keep an in-memory version of what we store in sessionStorage:
        //  { tasks: [...], bigTimerEndTime: number|null, bigTimerRunning: boolean }
        let sessionData = {
            tasks: [],
            bigTimerEndTime: null,
            bigTimerRunning: false
        };

        /****************************************************
         * ON PAGE LOAD: RESTORE FROM sessionStorage (if any)
         ****************************************************/
        window.addEventListener('DOMContentLoaded', () => {
            restoreFromSession();
        });

        // HELPER: read from sessionStorage and reconstruct the UI
        function restoreFromSession() {
            const saved = sessionStorage.getItem('pomodoroData');
            if (!saved) {
                return;  // nothing to restore
            }

            sessionData = JSON.parse(saved);

            // Rebuild tasks from sessionData.tasks
            sessionData.tasks.forEach((taskData) => {
                createTaskRow(taskData);
            });

            // If the big timer was running, re-init it
            if (sessionData.bigTimerRunning && sessionData.bigTimerEndTime) {
                startBigTimerInterval(sessionData.bigTimerEndTime);
            } else {
                // Just update display with what's stored
                updateBigTimerDisplay(sessionData.bigTimerEndTime);
            }
        }

        /****************************************************
         * SAVE TO SESSIONSTORAGE
         ****************************************************/
        function saveToSession() {
            // We'll build sessionData.tasks from our tasks in-memory structure
            sessionData.tasks = tasks.map(t => {
                return {
                    name: t.taskNameInput.value.trim(),
                    minutes: parseInt(t.minutesInput.value, 10),
                    endTime: t.data.endTime,
                    finished: t.data.finished,
                    wasStarted: t.data.wasStarted
                };
            });

            sessionStorage.setItem('pomodoroData', JSON.stringify(sessionData));
        }

        /****************************************************
         * CREATE A TASK ROW (from scratch or from stored data)
         ****************************************************/
        function createTaskRow(stored) {
            // The object that tracks DOM + data for this task
            const taskObj = {
                // DOM references
                container: null,
                taskNameInput: null,
                minutesInput: null,
                startBtn: null,
                finishBtn: null,
                timerDisplay: null,
                resultElem: null,

                // data
                data: {
                    endTime: stored?.endTime || null,
                    finished: stored?.finished || false,
                    wasStarted: stored?.wasStarted || false
                },
                intervalId: null
            };

            // Create row
            const row = document.createElement('div');
            row.classList.add('task-row');

            // Task name
            const nameInput = document.createElement('input');
            nameInput.type = 'text';
            nameInput.placeholder = 'Task Name';
            nameInput.value = stored?.name || '';

            // Minutes
            const minsInput = document.createElement('input');
            minsInput.type = 'number';
            minsInput.min = '1';
            minsInput.placeholder = '5';
            minsInput.value = stored?.minutes || '';

            // Start button
            const startBtn = document.createElement('button');
            startBtn.textContent = 'Start';
            startBtn.addEventListener('click', () => handleStartTask(taskObj));

            // Finish button
            const finishBtn = document.createElement('button');
            finishBtn.textContent = 'Finish';
            finishBtn.addEventListener('click', () => finishTimer(taskObj));

            // Timer display
            const timerDisplay = document.createElement('div');
            timerDisplay.classList.add('timer-display');
            timerDisplay.textContent = '00:00';

            // Result
            const resultElem = document.createElement('div');
            resultElem.classList.add('result');

            // Append
            row.appendChild(nameInput);
            row.appendChild(minsInput);
            row.appendChild(startBtn);
            row.appendChild(finishBtn);
            row.appendChild(timerDisplay);
            row.appendChild(resultElem);

            // Insert into DOM
            document.getElementById('taskContainer').appendChild(row);

            // Fill in object
            taskObj.container = row;
            taskObj.taskNameInput = nameInput;
            taskObj.minutesInput = minsInput;
            taskObj.startBtn = startBtn;
            taskObj.finishBtn = finishBtn;
            taskObj.timerDisplay = timerDisplay;
            taskObj.resultElem = resultElem;

            // If this task was already started (on a previous session load),
            // we recreate its interval if not finished
            if (taskObj.data.wasStarted && !taskObj.data.finished && taskObj.data.endTime) {
                // Recreate the interval
                taskObj.intervalId = setInterval(() => updateTaskTimer(taskObj), 1000);
            }
            // If it was finished, we can show the final time or negative if needed
            if (taskObj.data.finished) {
                updateTaskTimer(taskObj);
            }

            tasks.push(taskObj);
        }

        /****************************************************
         * ADD TASK BUTTON
         ****************************************************/
        document.getElementById('addTaskBtn').addEventListener('click', () => {
            createTaskRow(null);
            saveToSession();
        });

        /****************************************************
         * START ALL BUTTON (CUMULATIVE)
         ****************************************************/
        document.getElementById('startAllBtn').addEventListener('click', () => {
            // Clear existing big timer
            if (totalIntervalId) {
                clearInterval(totalIntervalId);
            }

            let cumulativeMinutes = 0;
            const now = Date.now();

            for (let i = 0; i < tasks.length; i++) {
                const t = tasks[i];
                // Clear each task's interval if any
                if (t.intervalId) {
                    clearInterval(t.intervalId);
                    t.intervalId = null;
                }

                const nameVal = t.taskNameInput.value.trim();
                const minsVal = parseInt(t.minutesInput.value, 10);

                if (!nameVal) {
                    alert('Please provide a valid task name for all tasks.');
                    return;
                }
                if (isNaN(minsVal) || minsVal <= 0) {
                    alert('Please enter a valid number of minutes for all tasks.');
                    return;
                }

                // Increase cumulative
                cumulativeMinutes += minsVal;

                // Set endTime
                t.data.endTime = now + (cumulativeMinutes * 60 * 1000);
                t.data.finished = false;
                t.data.wasStarted = true;
                t.resultElem.textContent = '';
                t.timerDisplay.classList.remove('negative');

                // Start this task's interval
                t.intervalId = setInterval(() => updateTaskTimer(t), 1000);
            }

            // Big Timer
            sessionData.bigTimerEndTime = now + (cumulativeMinutes * 60 * 1000);
            sessionData.bigTimerRunning = true;
            startBigTimerInterval(sessionData.bigTimerEndTime);

            // Save
            saveToSession();
        });

        /****************************************************
         * START INDIVIDUAL TASK (MANUAL BUTTON)
         * If you still want to allow single-task starts
         ****************************************************/
        function handleStartTask(taskObj) {
            if (taskObj.intervalId) {
                clearInterval(taskObj.intervalId);
            }

            const nameVal = taskObj.taskNameInput.value.trim();
            const minsVal = parseInt(taskObj.minutesInput.value, 10);

            if (!nameVal) {
                alert('Please provide a valid task name.');
                return;
            }
            if (isNaN(minsVal) || minsVal <= 0) {
                alert('Please enter a valid number of minutes.');
                return;
            }

            const now = Date.now();
            taskObj.data.endTime = now + (minsVal * 60 * 1000);
            taskObj.data.finished = false;
            taskObj.data.wasStarted = true;
            taskObj.resultElem.textContent = '';
            taskObj.timerDisplay.classList.remove('negative');

            taskObj.intervalId = setInterval(() => updateTaskTimer(taskObj), 1000);

            // Save
            saveToSession();
        }

        /****************************************************
         * START BIG TIMER INTERVAL
         ****************************************************/
        function startBigTimerInterval(endTime) {
            if (totalIntervalId) clearInterval(totalIntervalId);

            const bigTimerElem = document.getElementById('bigTimer');
            bigTimerElem.classList.remove('negative');

            totalIntervalId = setInterval(() => {
                updateBigTimerDisplay(endTime);
            }, 1000);

            // Immediately update once
            updateBigTimerDisplay(endTime);
        }

        /****************************************************
         * UPDATE BIG TIMER DISPLAY
         ****************************************************/
        function updateBigTimerDisplay(endTime) {
            const bigTimerElem = document.getElementById('bigTimer');
            if (!endTime) {
                bigTimerElem.textContent = '00:00';
                return;
            }

            const now = Date.now();
            const timeLeft = Math.floor((endTime - now) / 1000);

            if (timeLeft <= 0) {
                // Negative
                const lateSeconds = Math.abs(timeLeft);
                const mins = Math.floor(lateSeconds / 60);
                const secs = lateSeconds % 60;
                bigTimerElem.classList.add('negative');
                bigTimerElem.textContent = `-${padZero(mins)}:${padZero(secs)}`;
            } else {
                // Positive
                const mins = Math.floor(timeLeft / 60);
                const secs = timeLeft % 60;
                bigTimerElem.classList.remove('negative');
                bigTimerElem.textContent = `${padZero(mins)}:${padZero(secs)}`;
            }
        }

        /****************************************************
         * UPDATE INDIVIDUAL TASK TIMER
         ****************************************************/
        function updateTaskTimer(taskObj) {
            const now = Date.now();
            const timeLeft = Math.floor((taskObj.data.endTime - now) / 1000);

            if (timeLeft <= 0) {
                // Negative
                const lateSeconds = Math.abs(timeLeft);
                const mins = Math.floor(lateSeconds / 60);
                const secs = lateSeconds % 60;
                taskObj.timerDisplay.classList.add('negative');
                taskObj.timerDisplay.textContent = `-${padZero(mins)}:${padZero(secs)}`;
            } else {
                // Positive
                const mins = Math.floor(timeLeft / 60);
                const secs = timeLeft % 60;
                taskObj.timerDisplay.classList.remove('negative');
                taskObj.timerDisplay.textContent = `${padZero(mins)}:${padZero(secs)}`;
            }
        }

        /****************************************************
         * FINISH TIMER
         ****************************************************/
        function finishTimer(taskObj) {
            if (taskObj.intervalId) {
                clearInterval(taskObj.intervalId);
                taskObj.intervalId = null;
            }

            taskObj.data.finished = true;

            // Compute final message
            const now = Date.now();
            const timeLeft = Math.floor((taskObj.data.endTime - now) / 1000);
            const taskName = taskObj.taskNameInput.value.trim();

            if (timeLeft > 0) {
                taskObj.resultElem.textContent =
                    `"${taskName}" finished with ${timeLeft} seconds left!`;
            } else {
                const lateSeconds = Math.abs(timeLeft);
                taskObj.resultElem.textContent =
                    `"${taskName}" finished ${lateSeconds} seconds late...`;
            }

            // Update session
            saveToSession();
        }

        /****************************************************
         * HELPER: PAD WITH ZERO
         ****************************************************/
        function padZero(num) {
            return num < 10 ? '0' + num : num;
        }
    </script>
</body>

</html>